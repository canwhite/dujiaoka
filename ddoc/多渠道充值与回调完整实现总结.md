# DuJiaoKa 多渠道充值与回调完整实现指南

## 📖 文档概述

本文档详细说明了 DuJiaoKa 项目中实现多渠道充值回调和支付成功后重定向的完整方案。

**涉及功能：**
1. ✅ 支持多渠道充值（小说、游戏、VIP等）
2. ✅ 支付成功后根据 from 参数自动跳转回原网站
3. ✅ API Hook 异步调用第三方充值接口

---

## 🎯 业务场景

### 用户故事

**场景：** 用户在小说网站充值章节

```
1. 用户在小说网站（127.0.0.1:3000）点击充值
   ↓
2. 跳转到 DuJiaoKa 支付页面（带着 from=novel 参数）
   ↓
3. 用户完成支付
   ↓
4. DuJiaoKa 自动调用小说网站的充值 API
   ↓
5. 支付成功后自动跳转回小说网站
```

### 技术要点

- **from 参数**：标识订单来源（如 `novel`、`game`、`vip`）
- **异步 API 调用**：支付成功后后台调用第三方充值接口
- **前端重定向**：支付成功后自动跳转回原网站
- **解耦设计**：API 调用和前端跳转完全独立，互不影响

---

## 📊 完整数据流程图

```
┌─────────────────────────────────────────────────────────────────────┐
│                   完整的支付与回调流程                                │
└─────────────────────────────────────────────────────────────────────┘

T0: 用户创建订单
─────────────────────────────────────────────────────────────────────
URL: http://localhost:9595/buy/1?email=test@gmail.com&from=novel
    ↓
OrderController::createOrder()
    ↓
保存 from 参数到 order->info:
"充值账号: test@gmail.com\n来源: novel"

T1: 用户进入支付页面
─────────────────────────────────────────────────────────────────────
用户点击"立即支付"
    ↓
AlipayController::gateway('alipayscan', $orderSN)
    ↓
PayController::render('static_pages/qrpay', $result, ...)
    ↓
⭐ 自动添加：
$data['from'] = 'novel'
$data['redirect_urls'] = ['novel' => 'http://127.0.0.1:3000']
    ↓
渲染 qrpay.blade.php

T2: 用户等待支付完成
─────────────────────────────────────────────────────────────────────
前端每5秒轮询：
GET /check-order-status/{orderSN}
    ↓
返回：{code: 400000, msg: 'wait....'}

T3: 用户完成支付
─────────────────────────────────────────────────────────────────────
用户扫码支付
    ↓
支付网关回调 DuJiaoKa
    ↓
OrderProcessService::success($order)

T4: 后端处理订单（同步，立即完成）
─────────────────────────────────────────────────────────────────────
┌───────────────────────────────────────────────────────────────────┐
│ 1. 更新订单状态为"已支付"                                          │
│    $order->status = Order::STATUS_SUCCESS;                        │
│    $order->save();                                                │
│    ↓                                                             │
│ 2. 处理发货（自动发货则发送卡密）                                  │
│    processAuto($order);                                          │
│    ↓                                                             │
│ 3. 提交事务（订单状态已保存到数据库）                              │
│    DB::commit();                                                  │
│    ↓                                                             │
│ 4. ⭐ 此时订单状态已更新，前端可以检测到了！                        │
└───────────────────────────────────────────────────────────────────┘

T5: 触发异步 Jobs（后台慢慢执行）
─────────────────────────────────────────────────────────────────────
┌───────────────────────────────────────────────────────────────────┐
│ TelegramPush::dispatch($order)     // TG推送                      │
│ BarkPush::dispatch($order)          // Bark推送                    │
│ WorkWeiXinPush::dispatch($order)   // 企业微信推送                 │
│ ApiHook::dispatch($order)          // ⭐ API回调                  │
└───────────────────────────────────────────────────────────────────┘
                            │
                            ▼
              ┌─────────────────────────────┐
              │  ApiHook Job（异步执行）      │
              └─────────────────────────────┘
                            │
                            ▼
              提取 from=novel
                            │
                            ▼
              调用 callNovelApi()
                            │
                            ▼
              发送POST请求到：
              http://novel-api:8080/api/v1/users/recharge
                            │
                            ▼
              传递数据：
              {
                "email": "test@gmail.com",
                "order_sn": "20241230123456",
                "amount": 9.99,
                "good_name": "小说充值-100章"
              }

T6: 前端轮询检测到状态变化
─────────────────────────────────────────────────────────────────────
前端轮询：
GET /check-order-status/{orderSN}
    ↓
返回：{code: 200, msg: 'success'}  ✅ 支付成功
    ↓
停止轮询

T7: 前端执行跳转
─────────────────────────────────────────────────────────────────────
┌───────────────────────────────────────────────────────────────────┐
│ 前端 JavaScript：                                                 │
│                                                                   │
│ const from = 'novel';                                            │
│ const redirectUrls = {novel: 'http://127.0.0.1:3000'};           │
│                                                                   │
│ if (from && redirectUrls[from]) {                                │
│     redirectUrl = redirectUrls[from];                             │
│ }                                                                │
│                                                                   │
│ alert("支付成功！3秒后自动跳转...");                              │
│                                                                   │
│ setTimeout(function() {                                          │
│     window.location.href = 'http://127.0.0.1:3000';             │
│ }, 3000);                                                       │
└───────────────────────────────────────────────────────────────────┘

T8: 并行状态
─────────────────────────────────────────────────────────────────────
┌──────────────────────────┐         ┌──────────────────────────┐
│  用户浏览器：              │         │  服务器后台：              │
│  已跳转到小说网站          │         │  ApiHook 还在执行          │
│  127.0.0.1:3000           │         │  调用充值API               │
│                          │         │                            │
│  ✅ 用户已回到小说网站     │         │  ⏳ 充值API调用中           │
└──────────────────────────┘         └──────────────────────────┘
```

---

## 🔧 核心实现

### 1. 订单创建时保存 from 参数

**文件：** `app/Http/Controllers/Home/OrderController.php`

**代码：**
```php
// 第72-76行
$otherIpt = $this->orderService->validatorChargeInput($goods, $request);

// ⭐ 获取from参数并追加到otherIpt（支持订单来源标识）
$from = $request->input('from', '');
if (!empty($from)) {
    $otherIpt = $otherIpt . "\n来源: " . $from;
}

$this->orderProcessService->setOtherIpt($otherIpt);
```

**存储格式：**
```
order->info = "充值账号: test@gmail.com\n来源: novel"
```

---

### 2. API Hook 异步调用第三方充值接口

**文件：** `app/Jobs/ApiHook.php`

**核心方法：**

#### 2.1 handle() - Job 入口

```php
public function handle()
{
    $goodInfo = $this->goodsService->detail($this->order->goods_id);

    if(empty($goodInfo->api_hook)){
        return;
    }

    // ⭐ 从订单info中提取from参数
    $from = '';
    if (!empty($this->order->info)) {
        if (preg_match('/来源[:\s]+([^\s\n]+)/', $this->order->info, $matches)) {
            $from = $matches[1];
        }
    }

    // ⭐⭐⭐ 根据from参数进行不同的API请求
    $this->callApiByFrom($from, $goodInfo);
}
```

#### 2.2 callApiByFrom() - 分发器

```php
private function callApiByFrom($from, $goodInfo)
{
    if (empty($from)) {
        $this->sendDefaultApiHook($goodInfo);
        return;
    }

    switch ($from) {
        case 'novel':
            $this->callNovelApi($goodInfo);
            break;

        case 'game':
            $this->callGameApi($goodInfo);
            break;

        case 'vip':
            $this->callVipApi($goodInfo);
            break;

        case 'app':
            $this->callAppApi($goodInfo);
            break;

        default:
            $this->sendDefaultApiHook($goodInfo);
            break;
    }
}
```

#### 2.3 callNovelApi() - 小说充值

```php
private function callNovelApi($goodInfo)
{
    $apiUrl = env('NOVEL_API_URL', '');

    if (empty($apiUrl)) {
        return;
    }

    // 从订单info中提取邮箱
    $email = '';
    if (!empty($this->order->info)) {
        if (preg_match('/充值账号[:\s]+([^\s\n]+)/', $this->order->info, $matches)) {
            $email = $matches[1];
        }
    }

    $postdata = [
        'email' => $email,
        'order_sn' => $this->order->order_sn,
        'amount' => $this->order->actual_price,
        'good_name' => $goodInfo->gd_name,
        'timestamp' => time()
    ];

    $this->sendPostRequest($apiUrl, $postdata);
}
```

#### 2.4 sendPostRequest() - 通用请求方法

```php
private function sendPostRequest($url, $data)
{
    $opts = [
        'http' => [
            'method'  => 'POST',
            'header'  => 'Content-type: application/json',
            'content' => json_encode($data, JSON_UNESCAPED_UNICODE),
            'timeout' => 30
        ]
    ];

    $context = stream_context_create($opts);

    try {
        $result = @file_get_contents($url, false, $context);

        if ($result === false) {
            \Log::error('API Hook请求失败', [
                'url' => $url,
                'data' => $data,
                'error' => error_get_last()
            ]);
        } else {
            \Log::info('API Hook请求成功', [
                'url' => $url,
                'response' => $result
            ]);
        }
    } catch (\Exception $e) {
        \Log::error('API Hook异常', [
            'url' => $url,
            'data' => $data,
            'exception' => $e->getMessage()
        ]);
    }
}
```

---

### 3. 支付成功后自动重定向

#### 3.1 PayController 自动添加参数

**文件：** `app/Http/Controllers/PayController.php`

**新增方法1：extractFromFromOrder()**

```php
/**
 * ⭐ 从订单信息中提取 from 参数
 */
protected function extractFromFromOrder(): string
{
    if (empty($this->order->info)) {
        return '';
    }

    if (preg_match('/来源[:\s]+([^\s\n]+)/', $this->order->info, $matches)) {
        return $matches[1];
    }

    return '';
}
```

**新增方法2：重写 render()**

```php
/**
 * ⭐ 重写 render 方法，自动为 qrpay 页面添加 from 和 redirect_urls
 */
protected function render(string $tpl, $data = [], string $pageTitle = '')
{
    // ⭐ 如果是 qrpay 页面，自动添加 from 和 redirect_urls
    if ($tpl === 'static_pages/qrpay') {
        $data['from'] = $this->extractFromFromOrder();
        $data['redirect_urls'] = [
            'novel' => 'http://127.0.0.1:3000',
        ];
    }

    return parent::render($tpl, $data, $pageTitle);
}
```

**关键点：**
- 只在 `qrpay` 页面添加参数（其他页面不需要）
- 自动提取 from 参数
- 配置重定向 URL 映射
- 所有支付方式自动生效（支付宝、微信、Payjs等）

#### 3.2 前端实现重定向逻辑

**文件：** `resources/views/unicorn/static_pages/qrpay.blade.php`

**JavaScript 代码：**

```javascript
var getting = {
    url: '{{ url('check-order-status', ['orderSN' => $orderid]) }}',
    dataType: 'json',
    success: function(res) {
        if (res.code == 200) {
            window.clearTimeout(timer);

            // ⭐ 获取 from 参数和重定向配置
            const from = '{{ $from ?? '' }}';
            const redirectUrls = @json($redirect_urls ?? []);

            // ⭐ 根据 from 决定跳转 URL
            let redirectUrl = '{{ url('detail-order-sn', ['orderSN' => $orderid]) }}'; // 默认跳转

            if (from && redirectUrls[from]) {
                redirectUrl = redirectUrls[from];
            }

            // 提示用户
            alert("支付成功！3秒后自动跳转...");

            // 3秒后跳转
            setTimeout(function() {
                window.location.href = redirectUrl;
            }, 3000);
        }
    }
};

var timer = window.setInterval(function(){$.ajax(getting)}, 5000);
```

---

## 📂 相关文件清单

### 后端文件

| 文件路径 | 修改内容 | 说明 |
|---------|---------|------|
| `app/Http/Controllers/Home/OrderController.php` | 保存 from 参数 | 第72-76行 |
| `app/Http/Controllers/Home/HomeController.php` | 接收 from 参数 | buy() 方法 |
| `app/Jobs/ApiHook.php` | API 回调逻辑 | 完整实现 |
| `app/Service/OrderProcessService.php` | 触发 ApiHook | 第432行 |
| `app/Http/Controllers/PayController.php` | 提取 from + 重写 render | 新增2个方法 |

### 前端文件

| 文件路径 | 修改内容 | 说明 |
|---------|---------|------|
| `resources/views/unicorn/static_pages/buy.blade.php` | 邮箱自动填充 | 已完成 |
| `resources/views/unicorn/static_pages/qrpay.blade.php` | 重定向逻辑 | 第45-67行 |
| `resources/views/luna/static_pages/buy.blade.php` | 邮箱自动填充 | 已完成 |
| `resources/views/luna/static_pages/qrpay.blade.php` | 重定向逻辑 | 第92-113行 |

### 配置文件

| 文件路径 | 配置内容 |
|---------|---------|
| `.env` | API 地址配置 |
| `docker-compose.yml` | Docker 网络配置 |

---

## ⚙️ 环境配置

### 1. Docker 网络配置

**文件：** `docker-compose.yml`

```yaml
services:
  dujiaoka:
    networks:
      - dujiaoka_network
      - bepusdt_default
      - novelapi  # ⭐ 添加 novelapi 网络

networks:
  dujiaoka_network:
    driver: bridge
  bepusdt_default:
    external: true
  novelapi:
    external: true
    name: novel-resource-management_novel-network
```

### 2. 环境变量配置

**文件：** `.env`

```bash
# 外部API配置
NOVEL_API_URL=http://novel-api:8080/api/v1/users/recharge
GAME_API_URL=http://novel-api:8080/api/game/recharge
VIP_API_URL=http://novel-api:8080/api/vip/recharge
APP_API_URL=http://novel-api:8080/api/app/recharge
```

---

## 🧪 测试指南

### 测试场景1：小说网站充值

**步骤：**

1. **创建订单**
   ```
   http://localhost:9595/buy/1?email=test@gmail.com&from=novel
   ```

2. **完成支付**
   - 使用测试支付方式
   - 或手动在后台标记为已支付

3. **验证 API 调用**
   ```bash
   docker logs dujiaoka_app | grep "API Hook"

   # 应该看到：
   # [2024-12-30 12:34:56] local.INFO: API Hook请求成功
   ```

4. **验证前端跳转**
   - 支付成功后弹出："支付成功！3秒后自动跳转..."
   - 3秒后跳转到 `http://127.0.0.1:3000`

---

### 测试场景2：无 from 参数（默认行为）

**步骤：**

1. **创建订单**
   ```
   http://localhost:9595/buy/1?email=test@gmail.com
   ```

2. **完成支付**

3. **验证行为**
   - ApiHook 调用默认的 api_hook 地址
   - 前端跳转到订单详情页

---

### 测试场景3：验证数据存储

**查询订单：**

```bash
docker exec -it dujiaoka_app mysql -u root -p715705@Qc123 dujiaoka

mysql> SELECT order_sn, info FROM orders WHERE order_sn = '20241230123456';
```

**预期结果：**
```
+---------------+--------------------------------------------+
| order_sn      | info                                       |
+---------------+--------------------------------------------+
| 20241230123456 | 充值账号: test@gmail.com                   |
|               | 来源: novel                                 |
+---------------+--------------------------------------------+
```

---

## 🔍 调试方法

### 1. 查看 Laravel 日志

```bash
docker logs -f dujiaoka_app
```

### 2. 查看 API Hook 日志

```bash
docker logs dujiaoka_app | grep "API Hook"
```

### 3. 查看订单信息

```bash
# 登录容器
docker exec -it dujiaoka_app bash

# 查询数据库
mysql -u root -p715705@Qc123 dujiaoka

SELECT order_sn, status, info FROM orders ORDER BY id DESC LIMIT 5;
```

### 4. 前端调试

打开浏览器开发者工具：

**Network 标签页：**
- 查看 `/check-order-status` 请求
- 确认返回 `{code: 200, msg: 'success'}`

**Console 标签页：**
- 查看 from 和 redirectUrls 的值
- 确认跳转 URL 正确

---

## ⚠️ 注意事项

### 1. API Hook 异步执行

**重要：** ApiHook 是异步队列任务，在后台执行

**含义：**
- ✅ 不会阻塞订单状态更新
- ✅ 不会影响前端跳转
- ✅ 失败不影响订单

**验证：**
```bash
# 查看队列任务
docker exec dujiaoka_app php artisan queue:failed
```

---

### 2. 前端轮询机制

**轮询频率：** 每5秒检查一次

**超时时间：** 订单过期时间（默认5分钟）

**停止条件：**
- 订单过期
- 支付成功

---

### 3. URL 协议问题

**问题：** 如果 dujiaoka 使用 https，跳转到 http 地址会被浏览器阻止

**解决方案：**
- 目标站点也使用 https
- 或使用相对路径

---

### 4. Docker 网络连接

**确保：**
- dujiaoka 容器连接到 novelapi 网络
- novel-api 容器正常运行
- 可以通过容器名访问：`http://novel-api:8080`

**验证：**
```bash
docker exec dujiaoka_app curl http://novel-api:8080
```

---

## 🚀 扩展指南

### 添加新的充值渠道

**场景：** 添加游戏网站充值

**步骤：**

1. **修改 ApiHook.php**
   ```php
   switch ($from) {
       case 'novel':
           $this->callNovelApi($goodInfo);
           break;

       case 'game':  // ⭐ 新增
           $this->callGameApi($goodInfo);
           break;
   }
   ```

2. **实现 callGameApi()**
   ```php
   private function callGameApi($goodInfo)
   {
       $apiUrl = env('GAME_API_URL', '');

       $postdata = [
           'game_account' => $gameAccount,
           'order_sn' => $this->order->order_sn,
           'amount' => $this->order->actual_price
       ];

       $this->sendPostRequest($apiUrl, $postdata);
   }
   ```

3. **配置环境变量**
   ```bash
   # .env
   GAME_API_URL=http://novel-api:8080/api/game/recharge
   ```

4. **配置重定向 URL**
   ```php
   // PayController.php
   $data['redirect_urls'] = [
       'novel' => 'http://127.0.0.1:3000',
       'game' => 'http://127.0.0.1:4000',  // ⭐ 新增
   ];
   ```

5. **测试**
   ```
   http://localhost:9595/buy/1?email=test@gmail.com&from=game
   ```

---

## 📊 架构设计亮点

### 1. 解耦设计

**API 调用和前端跳转完全独立：**

```
支付成功
    ├──→ 后端：ApiHook 异步调用充值API
    │   └── 不影响用户，慢慢执行
    │
    └──→ 前端：立即检测到状态变化
        └── 立即跳转（不等 API 执行完）
```

### 2. 策略模式

**根据 from 参数选择不同的处理方式：**

```php
switch ($from) {
    case 'novel': → callNovelApi()
    case 'game':  → callGameApi()
    case 'vip':    → callVipApi()
    default:       → sendDefaultApiHook()
}
```

### 3. 模板方法模式

**父类统一处理，子类无需修改：**

```php
// PayController
protected function render($tpl, $data, $pageTitle) {
    if ($tpl === 'static_pages/qrpay') {
        // 统一添加 from 和 redirect_urls
    }
    return parent::render($tpl, $data, $pageTitle);
}

// AlipayController, WepayController, PayjsController
// 完全不需要修改，自动生效
```

---

## 📝 总结

### 实现的功能

✅ **多渠道充值**
- 支持 novel、game、vip、app 等多个渠道
- 每个渠道调用不同的 API
- 可轻松扩展新渠道

✅ **支付成功后自动跳转**
- 根据 from 参数自动跳转回原网站
- 提升用户体验
- 支持默认行为（跳转到订单详情页）

✅ **异步 API 调用**
- 不阻塞订单流程
- 失败不影响支付
- 完善的日志记录

✅ **代码质量**
- 解耦设计
- 易于维护
- 易于扩展

### 修改的文件

**总计：9个文件**

- 后端：5个
- 前端：4个
- 配置：2个

### 代码行数

**新增代码：约300行**
- 后端：约200行
- 前端：约100行

---

## 📚 相关文档

- [ApiHook多渠道充值回调实现详解](./ApiHook多渠道充值回调实现详解.md)
- [file_get_contents方法详解与重定向实现](./file_get_contents方法详解与重定向实现.md)
- [支付成功页面流程调查报告](./支付成功页面流程调查报告.md)
- [ApiHook与支付成功回调的关系分析](./ApiHook与支付成功回调的关系分析.md)
- [支付成功重定向-最终优化方案](./支付成功重定向-最终优化方案.md)

---

**📌 文档版本：v1.0.0**
**创建日期：2024-12-30**
**最后更新：2024-12-30**
**作者：Claude Code Assistant**
